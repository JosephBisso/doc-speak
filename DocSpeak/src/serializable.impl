using namespace docspeak;

template<typename T>
std::shared_ptr<Book<T>> Book<T>::s_instance;

template<typename T>
std::weak_ptr<Book<T>> Book<T>::get_book() {
    if (!s_instance) 
        s_instance = std::shared_ptr<Book>(new Book<T>);
    
    return s_instance;
}

template<typename T>
void Book<T>::init_book() {
    if (!s_instance) 
        s_instance = std::shared_ptr<Book>(new Book<T>);
}

template<typename T>
void Book<T>::clear_book() {
    if (!s_instance) 
        return;
    
    s_instance->clear();
}

template<typename T>
void Book<T>::clear() {
    if (!s_instance) 
        return;
    
    s_instance->m_elements.clear();
}

template<typename T>
size_t Book<T>::size() {
    if (!s_instance) 
        return 0;
    
    return s_instance->m_elements.size();
}

template<typename T>
std::vector<std::shared_ptr<T>>& Book<T>::get_all() {
    if (!s_instance) 
        init_book();
    
    return s_instance->m_elements;
}

// template<typename T>
// void Book<T>::add(std::shared_ptr<T> element) {
//     m_elements.push_back(element);
// }

template<typename T>
void Book<T>::save(const std::filesystem::path&){
    
}

template<typename T>
void Book<T>::load(const std::filesystem::path&){

}

template<typename T>
std::vector<std::weak_ptr<T>> Book<T>::find(const T& to_find) {
    std::vector<std::weak_ptr<T>> results;
    auto all_elements = get_all();

    std::copy_if(all_elements.begin(), all_elements.end(),
                std::back_inserter(results), [&to_find] (auto element){ 
            return element -> is_like(to_find);
    });

    return results;
}
